{"version":3,"sources":["template-lint.ts"],"names":[],"mappings":"AAAA,YAAY,CAAC;AAEb,yBAA8C,QAAQ,CAAC,CAAA;AACvD,MAAY,MAAM,WAAM,QAAQ,CAAC,CAAA;AACjC,yBAAuB,QAAQ,CAAC,CAAA;AAEhC;;EAEE;AACF;AAKA,CAAC;AAED;;GAEG;AACH,4BAA4B,IAAI;IAG5B,IAAI,CAAC,MAAiB,EAAE,IAAa;QACjC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,IAAI,GAAG,IAAI,CAAC;QAEhB,MAAM,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ;YACrD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,WAAW,CAAC,CAAC;QAChD,CAAC,CAAC,CAAC;IACP,CAAC;IACD,IAAI,CAAC,SAAwB;QACzB,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,MAAM,CAAC,SAAS;aACX,IAAI,CAAC;YACF,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC;gBACrB,MAAM,QAAQ,CAAC;QACvB,CAAC,CAAC,CAAC;IACX,CAAC;AACL,CAAC;AAED;;GAEG;AACH,+BAA+B,IAAI;IAM/B,IAAI,CAAC,MAAiB,EAAE,IAAa;QACjC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QAErB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,IAAI,UAAU,CAAC;IAC9C,CAAC;IAED,IAAI,CAAC,SAAwB;QACzB,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC1E,CAAC;AACL,CAAC;AAED;;GAEG;AACH,0BAA0B,IAAI;IAG1B,IAAI,CAAC,MAAiB,EAAE,IAAa;QACjC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,IAAI,GAAG,IAAI,CAAC;QAEhB,MAAM,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ;YACrD,EAAE,CAAC,CAAC,IAAI,IAAI,SAAS,CAAC;gBAClB,MAAM,CAAC;YAEX,IAAI,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACxB,MAAM,CAAO,CAAE,CAAC,IAAI,IAAI,MAAM,CAAA;YAClC,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,CAAC,QAAQ,CAAC;gBACT,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACvB,IAAI;gBACA,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QAE5B,CAAC,CAAC,CAAC;IACP,CAAC;IACD,IAAI,CAAC,SAAwB;QACzB,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,MAAM,CAAC,SAAS;aACX,IAAI,CAAC;YACF,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC;gBACrB,MAAM,QAAQ,CAAC;QACvB,CAAC,CAAC,CAAC;IACX,CAAC;AACL,CAAC;AAED;IAII;QACI,IAAI,CAAC,KAAK,GAAG;YACT,IAAI,gBAAgB,EAAE;YACtB,IAAI,aAAa,EAAE;YACnB,IAAI,WAAW,EAAE;SACpB,CAAC;IACN,CAAC;IAED,IAAI,CAAC,IAAY;QACb,IAAI,MAAM,GAAc,IAAI,kBAAS,CAAC,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;QAC9D,IAAI,MAAM,GAAa,IAAI,iBAAQ,EAAE,CAAC;QAEtC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAClB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAElB,IAAI,IAAI,GAAG,MAAM,CAAC,aAAa,CAAC,IAAI,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;QAE9D,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI;YACpB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAA;QACzC,CAAC,CAAC,CAAC;QAEH,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAE/B,IAAI,SAAS,GAAG,IAAI,OAAO,CAAO,UAAU,OAAO,EAAE,MAAM;YACvD,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,QAAQ,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,IAAI,SAAS,GAAG,EAAE,CAAC;QAEnB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI;YACpB,IAAI,IAAI,GAAG,IAAI;iBACV,IAAI,CAAC,SAAS,CAAC;iBACf,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC;YACtB,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC;IACtE,CAAC;AACL,CAAC;AAEQ,cAAM,UAFd;AAEiB","file":"template-lint.js","sourcesContent":["\"use strict\";\r\n\r\nimport {SAXParser, TreeAdapter, ASTNode} from 'parse5';\r\nimport * as parse5 from 'parse5';\r\nimport {Readable} from 'stream';\r\n\r\n/**\r\n* Abstract Lint Rule \r\n*/\r\nabstract class Rule {\r\n    public name: string;\r\n    public description: string;\r\n    abstract init(parse: SAXParser, root: ASTNode);\r\n    abstract lint(completed: Promise<void>): Promise<void>;\r\n}\r\n\r\n/**\r\n * Rule to ensure non-void elements do not self-close\r\n */\r\nclass SelfCloseRule extends Rule {\r\n    private parser: SAXParser;\r\n    public result: boolean;\r\n    init(parser: SAXParser, root: ASTNode) {\r\n        this.parser = parser;\r\n        this.result = true;\r\n        var self = this;\r\n\r\n        parser.on('startTag', (name, attrs, selfClosing, location) => {\r\n            self.result = self.result && (!selfClosing);\r\n        });\r\n    }\r\n    lint(completed: Promise<void>): Promise<void> {\r\n        var self = this;\r\n        return completed\r\n            .then(() => {\r\n                if (self.result == false)\r\n                    throw \"failed\";\r\n            });\r\n    }\r\n}\r\n\r\n/**\r\n *  Rule to ensure root element is the template element\r\n */\r\nclass TemplateRootRule extends Rule {\r\n    private parser: SAXParser;\r\n\r\n    public result: boolean;\r\n    public error: string;\r\n\r\n    init(parser: SAXParser, root: ASTNode) {\r\n        this.parser = parser;\r\n\r\n        this.result = root.nodeName == 'template';\r\n    }\r\n\r\n    lint(completed: Promise<void>): Promise<void> {\r\n        var self = this;\r\n        return (this.result) ? Promise.resolve() : Promise.reject(this.error);\r\n    }\r\n}\r\n\r\n/**\r\n *  Rule to ensure a require element is well formed\r\n */\r\nclass RequireRule extends Rule {\r\n    private parser: SAXParser;\r\n    public result: boolean;\r\n    init(parser: SAXParser, root: ASTNode) {\r\n        this.parser = parser;\r\n        this.result = true;\r\n        var self = this;\r\n\r\n        parser.on('startTag', (name, attrs, selfClosing, location) => {\r\n            if (name != 'require')\r\n                return;\r\n\r\n            var fromAttr = attrs.find((x) => {\r\n                return (<any>x).name == 'from'\r\n            });\r\n\r\n            if (fromAttr)\r\n                self.result = true;\r\n            else\r\n                self.result = false;\r\n\r\n        });\r\n    }\r\n    lint(completed: Promise<void>): Promise<void> {\r\n        var self = this;\r\n        return completed\r\n            .then(() => {\r\n                if (self.result == false)\r\n                    throw \"failed\";\r\n            });\r\n    }\r\n}\r\n\r\nclass Linter {\r\n\r\n    private rules: Array<Rule>;\r\n\r\n    constructor() {\r\n        this.rules = [\r\n            new TemplateRootRule(),\r\n            new SelfCloseRule(),\r\n            new RequireRule()\r\n        ];\r\n    }\r\n\r\n    lint(html: string): Promise<boolean> {\r\n        var parser: SAXParser = new SAXParser({ locationInfo: true });\r\n        var stream: Readable = new Readable();\r\n\r\n        stream.push(html);\r\n        stream.push(null);\r\n\r\n        var root = parse5.parseFragment(html, { locationInfo: true });\r\n\r\n        this.rules.forEach((rule) => {\r\n            rule.init(parser, root.childNodes[0])\r\n        });\r\n\r\n        var work = stream.pipe(parser);\r\n\r\n        var completed = new Promise<void>(function (resolve, reject) {\r\n            work.on(\"end\", () => { resolve(); });\r\n        });\r\n\r\n        var ruleTasks = [];\r\n\r\n        this.rules.forEach((rule) => {\r\n            var task = rule\r\n                .lint(completed)\r\n                .then(() => true);\r\n            ruleTasks.push(task);\r\n        });\r\n\r\n        return Promise.all(ruleTasks).then(() => true).catch(() => false);\r\n    }\r\n}\r\n\r\nexport { Linter };"],"sourceRoot":"../source"}